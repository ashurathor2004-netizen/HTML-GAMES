<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Magical Hand-Controlled Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        canvas { display: block; }
        #video-container {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 160px;
            height: 120px;
            z-index: 2;
            opacity: 0.7;
            border: 2px solid #00ffcc;
            border-radius: 8px;
            overflow: hidden;
            transform: scaleX(-1); /* Mirror the video */
        }
        #webcam { width: 100%; height: 100%; object-fit: cover; }
        #ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #fff;
            z-index: 10;
            pointer-events: none;
        }
        h1 { margin: 0; font-size: 1.5rem; text-shadow: 0 0 10px #00ffcc; }
        p { margin: 5px 0; color: #aaa; font-size: 0.9rem; }
        .gesture-hint {
            display: inline-block;
            background: rgba(0, 255, 204, 0.2);
            padding: 5px 10px;
            border-radius: 4px;
            margin-right: 5px;
            margin-top: 5px;
            border: 1px solid #00ffcc;
        }
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffcc;
            font-size: 1.5rem;
            z-index: 100;
        }
    </style>
</head>
<body>

    <div id="video-container">
        <video id="webcam" playsinline></video>
    </div>

    <div id="loading">Initializing Magic...</div>

    <div id="ui">
        <h1>Hand Particle System</h1>
        <p>Current Shape: <span id="shape-name" style="color: #00ffcc; font-weight: bold;">Sphere</span></p>
        <div>
            <span class="gesture-hint">‚òùÔ∏è 1: Sphere</span>
            <span class="gesture-hint">‚úåÔ∏è 2: Heart</span>
            <span class="gesture-hint">üëå 3: Flower</span>
            <span class="gesture-hint">üññ 4: Saturn</span>
        </div>
        <p>‚úä Fist to Collapse | üñê Open Hand to Expand</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- CONFIGURATION ---
        const PARTICLE_COUNT = 3000;
        const PARTICLE_SIZE = 0.15;
        const COLORS = [0x00ffcc, 0xff0066, 0x00ccff, 0xffcc00]; // Cyan, Pink, Blue, Yellow

        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer, particles, geometry, material;
        let targetPositions = []; // Array to hold target coords
        let currentShape = 'sphere';
        let handClosed = false;
        let hueShift = 0;

        // Shape Geometry Caches
        const shapes = {
            sphere: [],
            heart: [],
            flower: [],
            saturn: []
        };

        // --- 1. THREE.JS SETUP ---
        function initThree() {
            scene = new THREE.Scene();
            // Fog for depth
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 8;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Create Particles
            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);

            // Initialize mostly random positions
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 10;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 10;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 10;
                
                colors[i * 3] = 0;
                colors[i * 3 + 1] = 1; 
                colors[i * 3 + 2] = 0.8; 
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // Custom Texture for soft particles
            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');

            material = new THREE.PointsMaterial({
                size: PARTICLE_SIZE,
                map: sprite,
                vertexColors: true,
                transparent: true,
                alphaTest: 0.5,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // Pre-calculate shapes
            calculateShapes();
            
            // Set initial target
            targetPositions = shapes.sphere;

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        // --- 2. SHAPE MATHEMATICS ---
        function calculateShapes() {
            // 1. Sphere / Firework
            shapes.sphere = new Float32Array(PARTICLE_COUNT * 3);
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const r = 4 * Math.cbrt(Math.random()); 
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                shapes.sphere[i*3] = r * Math.sin(phi) * Math.cos(theta);
                shapes.sphere[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                shapes.sphere[i*3+2] = r * Math.cos(phi);
            }

            // 2. Heart
            shapes.heart = new Float32Array(PARTICLE_COUNT * 3);
            for(let i=0; i<PARTICLE_COUNT; i++) {
                // Heart formula
                const t = Math.random() * Math.PI * 2;
                // Distribute points to fill volume slightly
                const slice = Math.random(); 
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                const scale = 0.25 * Math.sqrt(slice); // Scale down
                
                shapes.heart[i*3] = x * scale;
                shapes.heart[i*3+1] = y * scale + 1; // Lift up slightly
                shapes.heart[i*3+2] = (Math.random()-0.5) * 2; // Thickness
            }

            // 3. Flower (Sine modulated sphere)
            shapes.flower = new Float32Array(PARTICLE_COUNT * 3);
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                // Modulate radius based on angles to create petals
                const rBase = 3;
                const rVar = 1.5 * Math.sin(5 * theta) * Math.sin(5 * phi);
                const r = rBase + rVar;
                
                shapes.flower[i*3] = r * Math.sin(phi) * Math.cos(theta);
                shapes.flower[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                shapes.flower[i*3+2] = r * Math.cos(phi);
            }

            // 4. Saturn (Sphere + Ring)
            shapes.saturn = new Float32Array(PARTICLE_COUNT * 3);
            for(let i=0; i<PARTICLE_COUNT; i++) {
                if(i < PARTICLE_COUNT * 0.7) {
                    // Planet Body
                    const r = 2.5 * Math.cbrt(Math.random());
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    shapes.saturn[i*3] = r * Math.sin(phi) * Math.cos(theta);
                    shapes.saturn[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                    shapes.saturn[i*3+2] = r * Math.cos(phi);
                } else {
                    // Rings
                    const r = 4 + Math.random() * 2; // Ring radius 4 to 6
                    const theta = Math.random() * Math.PI * 2;
                    shapes.saturn[i*3] = r * Math.cos(theta);
                    shapes.saturn[i*3+1] = (Math.random() - 0.5) * 0.2; // Flat Y
                    shapes.saturn[i*3+2] = r * Math.sin(theta);
                }
            }
        }

        // --- 3. ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            const positions = particles.geometry.attributes.position.array;
            const colors = particles.geometry.attributes.color.array;

            // Cycle colors smoothly
            hueShift += 0.001;
            
            // Lerp Logic (Move current positions to target)
            // If hand is closed, we ignore target shape and move to 0,0,0
            
            const speed = 0.08; // Morph speed

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const px = positions[i*3];
                const py = positions[i*3+1];
                const pz = positions[i*3+2];

                let tx, ty, tz;

                if(handClosed) {
                    // Collapse to center
                    tx = 0; ty = 0; tz = 0;
                } else {
                    // Move to shape target
                    tx = targetPositions[i*3];
                    ty = targetPositions[i*3+1];
                    tz = targetPositions[i*3+2];
                }

                // Simple linear interpolation
                positions[i*3] += (tx - px) * speed;
                positions[i*3+1] += (ty - py) * speed;
                positions[i*3+2] += (tz - pz) * speed;

                // Color pulsing
                const color = new THREE.Color();
                color.setHSL((hueShift + i/PARTICLE_COUNT * 0.5) % 1, 0.8, 0.6);
                colors[i*3] = color.r;
                colors[i*3+1] = color.g;
                colors[i*3+2] = color.b;
            }

            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;
            
            // Auto rotate slightly
            particles.rotation.y += 0.002;

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function switchShape(shapeName) {
            if(currentShape === shapeName) return;
            currentShape = shapeName;
            document.getElementById('shape-name').innerText = shapeName.charAt(0).toUpperCase() + shapeName.slice(1);
            targetPositions = shapes[shapeName];
        }

        // --- 4. MEDIAPIPE HAND TRACKING ---
        const videoElement = document.getElementById('webcam');
        
        function onResults(results) {
            document.getElementById('loading').style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];

                // 1. Detect Hand Position for Rotation
                // Landmark 9 is the middle finger knuckle (center of hand approx)
                const handX = landmarks[9].x; // 0.0 to 1.0
                const handY = landmarks[9].y;
                
                // Map hand position to rotation (Simple interaction)
                // We reverse X because video is mirrored
                particles.rotation.x = (handY - 0.5) * 2; 
                particles.rotation.y = (0.5 - handX) * 2;

                // 2. Count Fingers (Basic Logic)
                // Tips: 8 (Index), 12 (Middle), 16 (Ring), 20 (Pinky)
                // Bases: 5, 9, 13, 17
                // Thumb: Tip 4, IP 3. Check X distance for thumb relative to wrist/palm direction, 
                // but simpler for now: check if Tip is above lower joint (y is lower at top of screen)
                
                let fingerCount = 0;
                
                // Note: In MediaPipe, y=0 is TOP. So "tip < base" means finger is UP.
                if (landmarks[8].y < landmarks[5].y) fingerCount++; // Index
                if (landmarks[12].y < landmarks[9].y) fingerCount++; // Middle
                if (landmarks[16].y < landmarks[13].y) fingerCount++; // Ring
                if (landmarks[20].y < landmarks[17].y) fingerCount++; // Pinky
                
                // Thumb logic is tricky due to rotation. 
                // Simple heuristic: If thumb tip x is far from pinky base x compared to index base x.
                // Or just ignore thumb for counting 1-4 to reduce noise.
                
                // 3. Detect Fist (Collapse)
                // If all fingers are curled (tip y > base y)
                const isFist = (
                    landmarks[8].y > landmarks[5].y &&
                    landmarks[12].y > landmarks[9].y &&
                    landmarks[16].y > landmarks[13].y &&
                    landmarks[20].y > landmarks[17].y
                );

                if (isFist) {
                    handClosed = true;
                } else {
                    handClosed = false;
                    // Switch shapes based on finger count
                    if (fingerCount === 1) switchShape('sphere');
                    if (fingerCount === 2) switchShape('heart');
                    if (fingerCount === 3) switchShape('flower');
                    if (fingerCount === 4) switchShape('saturn');
                }
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320,
            height: 240
        });

        // Initialize
        initThree();
        cameraFeed.start();

    </script>
</body>
</html>