<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Bubble Shooter</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* Prevent scrolling on mobile */
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
            z-index: 10;
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 20;
        }

        h1 {
            font-size: 40px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #e94560;
            text-shadow: 0 0 10px #e94560;
        }

        button {
            padding: 15px 30px;
            font-size: 24px;
            background: #0f3460;
            color: white;
            border: 2px solid #e94560;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            outline: none;
            box-shadow: 0 0 15px rgba(233, 69, 96, 0.4);
        }

        button:hover {
            background: #e94560;
            transform: scale(1.05);
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="ui-layer">
        Score: <span id="score">0</span>
    </div>
    
    <canvas id="gameCanvas"></canvas>

    <div id="start-screen">
        <h1>Bubble Pop</h1>
        <p>Tap or Click to Shoot</p>
        <button id="start-btn">Play Now</button>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1>Game Over</h1>
        <p>Final Score: <span id="final-score">0</span></p>
        <button id="restart-btn">Try Again</button>
    </div>
</div>

<script>
/**
 * AUDIO SYSTEM (Web Audio API)
 * Synthesized sounds to avoid external file dependencies.
 */
const AudioSys = {
    ctx: null,
    init: function() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    },
    playShoot: function() {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(400, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.1);
    },
    playPop: function() {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(600 + Math.random() * 200, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.15);
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.15);
    },
    playFail: function() {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(150, this.ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(50, this.ctx.currentTime + 0.5);
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.5);
    }
};

/**
 * GAME CONSTANTS & VARIABLES
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const finalScoreEl = document.getElementById('final-score');
const startScreen = document.getElementById('start-screen');
const gameOverScreen = document.getElementById('game-over-screen');

// Game Config
const COLORS = ['#FF4136', '#2ECC40', '#0074D9', '#FFDC00', '#B10DC9', '#FF851B']; // Red, Green, Blue, Yellow, Purple, Orange
let GRID_ROWS = 12;
let GRID_COLS = 10; // Will be adjusted based on screen width
let BUBBLE_RADIUS = 20;
let BOARD_WIDTH = 0;
let BOARD_HEIGHT = 0;

// Game State
let grid = [];
let particles = [];
let bullet = null;
let nextBubbleColor = null;
let score = 0;
let isGameOver = false;
let animationId;
let cannonAngle = 0;

// Mouse/Touch pos
let inputPos = { x: 0, y: 0 };

/**
 * INITIALIZATION & RESIZING
 */
function initGame() {
    resize();
    resetGame();
    setupInput();
    loop();
}

function resize() {
    // Determine grid size based on screen
    const isMobile = window.innerWidth < 600;
    
    // Max width constraint for desktop
    const maxWidth = isMobile ? window.innerWidth : 480;
    const maxHeight = window.innerHeight;

    canvas.width = maxWidth;
    canvas.height = maxHeight;
    
    BOARD_WIDTH = canvas.width;
    BOARD_HEIGHT = canvas.height;

    // Calculate optimal bubble size
    GRID_COLS = isMobile ? 10 : 12;
    BUBBLE_RADIUS = BOARD_WIDTH / (GRID_COLS * 2 + 1); // +1 to handle offset space
    
    // Re-center input
    inputPos = { x: BOARD_WIDTH / 2, y: BOARD_HEIGHT / 2 };
}

function resetGame() {
    score = 0;
    scoreEl.innerText = "0";
    isGameOver = false;
    grid = [];
    particles = [];
    bullet = null;

    // Create initial grid rows
    const initialRows = 5;
    for (let r = 0; r < GRID_ROWS; r++) {
        grid[r] = [];
        for (let c = 0; c < GRID_COLS; c++) {
            if (r < initialRows) {
                grid[r][c] = {
                    x: 0, y: 0, // Calculated in draw/update
                    color: COLORS[Math.floor(Math.random() * COLORS.length)],
                    active: true,
                    row: r, col: c
                };
            } else {
                grid[r][c] = { active: false, row: r, col: c, color: null };
            }
        }
    }
    
    nextBubbleColor = COLORS[Math.floor(Math.random() * COLORS.length)];
    prepareNextBullet();
}

function prepareNextBullet() {
    if(isGameOver) return;
    bullet = {
        x: BOARD_WIDTH / 2,
        y: BOARD_HEIGHT - BUBBLE_RADIUS - 10,
        color: nextBubbleColor,
        speed: 12, // Bullet speed
        angle: -Math.PI / 2, // Facing up
        moving: false,
        radius: BUBBLE_RADIUS
    };
    nextBubbleColor = COLORS[Math.floor(Math.random() * COLORS.length)];
}

/**
 * CORE LOGIC
 */

// Coordinate conversion
function getTileCoordinate(row, col) {
    let x = (col * BUBBLE_RADIUS * 2) + BUBBLE_RADIUS;
    // Shift every odd row
    if (row % 2 === 1) {
        x += BUBBLE_RADIUS;
    }
    let y = (row * BUBBLE_RADIUS * Math.sqrt(3)) + BUBBLE_RADIUS;
    return { x, y };
}

function getGridPosition(x, y) {
    const gridY = Math.round((y - BUBBLE_RADIUS) / (BUBBLE_RADIUS * Math.sqrt(3)));
    
    let xOffset = 0;
    if (gridY % 2 === 1) xOffset = BUBBLE_RADIUS;
    
    const gridX = Math.round((x - BUBBLE_RADIUS - xOffset) / (BUBBLE_RADIUS * 2));
    
    return { r: gridY, c: gridX };
}

// Find neighbors in hexagonal grid
function getNeighbors(r, c) {
    const neighbors = [];
    // Hexagonal neighbor offsets
    // Even rows: (0,-1), (0,1), (-1,-1), (-1,0), (1,-1), (1,0)
    // Odd rows:  (0,-1), (0,1), (-1,0), (-1,1), (1,0), (1,1)
    
    const parity = r % 2;
    const offsets = [
        {r: 0, c: -1}, {r: 0, c: 1},
        {r: -1, c: (parity === 0 ? -1 : 0)}, {r: -1, c: (parity === 0 ? 0 : 1)},
        {r: 1, c: (parity === 0 ? -1 : 0)}, {r: 1, c: (parity === 0 ? 0 : 1)}
    ];

    for (let off of offsets) {
        const nr = r + off.r;
        const nc = c + off.c;
        if (nr >= 0 && nr < GRID_ROWS && nc >= 0 && nc < GRID_COLS) {
            neighbors.push({r: nr, c: nc});
        }
    }
    return neighbors;
}

// Find cluster of same color
function findCluster(r, c, color, matchType, found, processed) {
    if (!found) found = [];
    if (!processed) processed = new Set();
    
    const key = `${r},${c}`;
    if (processed.has(key)) return found;
    processed.add(key);

    if (!grid[r] || !grid[r][c] || !grid[r][c].active) return found;
    
    // Determine matching condition
    let isMatch = false;
    if (matchType === 'color') {
        if (grid[r][c].color === color) isMatch = true;
    } else {
        // Any active bubble
        isMatch = true; 
    }

    if (isMatch) {
        found.push({r, c});
        const neighbors = getNeighbors(r, c);
        for (let n of neighbors) {
            findCluster(n.r, n.c, color, matchType, found, processed);
        }
    }
    return found;
}

// Find floating clusters (not attached to top)
function findFloatingClusters() {
    let processed = new Set();
    let found = [];
    
    // Start from top row (r=0) and find all connected
    for (let c = 0; c < GRID_COLS; c++) {
        if (grid[0][c] && grid[0][c].active) {
            findCluster(0, c, null, 'any', found, processed);
        }
    }

    const floating = [];
    for (let r = 0; r < GRID_ROWS; r++) {
        for (let c = 0; c < GRID_COLS; c++) {
            if (grid[r][c].active && !processed.has(`${r},${c}`)) {
                floating.push({r, c});
            }
        }
    }
    return floating;
}

function snapBubble() {
    const pos = getGridPosition(bullet.x, bullet.y);
    
    // Bounds check
    if (pos.c < 0) pos.c = 0;
    if (pos.c >= GRID_COLS) pos.c = GRID_COLS - 1;
    if (pos.r < 0) pos.r = 0;
    if (pos.r >= GRID_ROWS) pos.r = GRID_ROWS - 1; // Game Over check later

    // If spot taken, try to find nearest open spot (simple fallback)
    if (grid[pos.r][pos.c].active) {
        // This is a simplified collision resolution. 
        // Real bubble shooters use raycasting, but this works for simple cases.
        // We backtrack slightly along the angle
        bullet.x -= Math.cos(bullet.angle) * BUBBLE_RADIUS;
        bullet.y -= Math.sin(bullet.angle) * BUBBLE_RADIUS;
        const newPos = getGridPosition(bullet.x, bullet.y);
        pos.r = newPos.r;
        pos.c = newPos.c;
    }

    // Place bubble
    if(pos.r < GRID_ROWS && pos.c < GRID_COLS) {
        grid[pos.r][pos.c].active = true;
        grid[pos.r][pos.c].color = bullet.color;
        
        AudioSys.playShoot(); // Actually play the impact sound here

        // Check Matches
        const cluster = findCluster(pos.r, pos.c, bullet.color, 'color');
        
        if (cluster.length >= 3) {
            AudioSys.playPop();
            // Remove cluster
            let points = 0;
            cluster.forEach(b => {
                const coords = getTileCoordinate(b.r, b.c);
                createParticles(coords.x, coords.y, grid[b.r][b.c].color);
                grid[b.r][b.c].active = false;
                points += 10;
            });

            // Check for floating bubbles
            const floating = findFloatingClusters();
            if (floating.length > 0) {
                points += floating.length * 20; // Bonus for drops
                floating.forEach(b => {
                    const coords = getTileCoordinate(b.r, b.c);
                    createParticles(coords.x, coords.y, grid[b.r][b.c].color);
                    grid[b.r][b.c].active = false;
                });
            }
            score += points;
            scoreEl.innerText = score;
        }

        // Check Game Over (if bubble placed at bottom row)
        if (pos.r >= GRID_ROWS - 1) {
            triggerGameOver();
        }
    }

    prepareNextBullet();
}

function triggerGameOver() {
    isGameOver = true;
    AudioSys.playFail();
    finalScoreEl.innerText = score;
    gameOverScreen.classList.remove('hidden');
}

/**
 * ANIMATIONS & PARTICLES
 */
function createParticles(x, y, color) {
    for (let i = 0; i < 8; i++) {
        particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 6,
            vy: (Math.random() - 0.5) * 6,
            life: 1.0,
            color: color
        });
    }
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.05;
        if (p.life <= 0) particles.splice(i, 1);
    }
}

function update() {
    if (isGameOver) return;

    // Calculate Cannon Angle
    const dx = inputPos.x - (BOARD_WIDTH / 2);
    const dy = inputPos.y - (BOARD_HEIGHT - 30);
    cannonAngle = Math.atan2(dy, dx);
    // Limit angle so you can't shoot down
    if (cannonAngle > -0.2) cannonAngle = -0.2;
    if (cannonAngle < -Math.PI + 0.2) cannonAngle = -Math.PI + 0.2;

    // Update Bullet
    if (bullet && bullet.moving) {
        bullet.x += Math.cos(bullet.angle) * bullet.speed;
        bullet.y += Math.sin(bullet.angle) * bullet.speed;

        // Wall collisions
        if (bullet.x <= bullet.radius || bullet.x >= BOARD_WIDTH - bullet.radius) {
            bullet.angle = Math.PI - bullet.angle;
            bullet.x = bullet.x <= bullet.radius ? bullet.radius : BOARD_WIDTH - bullet.radius;
        }

        // Ceiling collision (snap)
        if (bullet.y <= bullet.radius) {
            bullet.y = bullet.radius;
            snapBubble();
        }

        // Bubble collisions
        else {
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    if (grid[r][c].active) {
                        const t = getTileCoordinate(r, c);
                        const dist = Math.hypot(bullet.x - t.x, bullet.y - t.y);
                        if (dist < BUBBLE_RADIUS * 2 - 4) { // -4 makes collision slightly forgiving
                            snapBubble();
                            return; // Stop update loop for this frame
                        }
                    }
                }
            }
        }
    }
    
    updateParticles();
}

function draw() {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 1. Draw Grid
    for (let r = 0; r < GRID_ROWS; r++) {
        for (let c = 0; c < GRID_COLS; c++) {
            const coord = getTileCoordinate(r, c);
            if (grid[r][c].active) {
                drawBubble(coord.x, coord.y, grid[r][c].color);
            } else {
                // Draw empty slot placeholder (faint)
                ctx.beginPath();
                ctx.arc(coord.x, coord.y, BUBBLE_RADIUS - 8, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,255,255,0.05)';
                ctx.fill();
            }
        }
    }

    // 2. Draw Bullet
    if (bullet) {
        drawBubble(bullet.x, bullet.y, bullet.color);
    }

    // 3. Draw Cannon
    ctx.save();
    ctx.translate(BOARD_WIDTH / 2, BOARD_HEIGHT - 20);
    ctx.rotate(cannonAngle);
    
    // Cannon barrel
    ctx.fillStyle = '#444';
    ctx.fillRect(0, -10, 60, 20);
    
    // Next Bubble preview inside cannon
    if(!bullet.moving) {
        ctx.beginPath();
        ctx.arc(0, 0, 15, 0, Math.PI*2);
        ctx.fillStyle = bullet.color;
        ctx.fill();
    }
    
    ctx.restore();

    // 4. Draw Particles
    particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        ctx.fill();
        ctx.globalAlpha = 1.0;
    });

    // 5. Draw Next Bubble Indicator (at bottom left)
    ctx.fillStyle = "white";
    ctx.font = "14px Arial";
    ctx.fillText("NEXT", 10, BOARD_HEIGHT - 40);
    drawBubble(30, BOARD_HEIGHT - 20, nextBubbleColor, 12);
}

function drawBubble(x, y, color, r = BUBBLE_RADIUS) {
    // Main circle
    ctx.beginPath();
    ctx.arc(x, y, r - 1, 0, Math.PI * 2);
    
    // Gradient for 3D look
    const grad = ctx.createRadialGradient(x - r/3, y - r/3, r/4, x, y, r);
    grad.addColorStop(0, '#fff'); // Highlight
    grad.addColorStop(0.3, color);
    grad.addColorStop(1, shadeColor(color, -40)); // Shadow
    
    ctx.fillStyle = grad;
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
    ctx.lineWidth = 1;
    ctx.stroke();
    
    // Shine
    ctx.beginPath();
    ctx.arc(x - r/3, y - r/3, r/4, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.fill();
}

// Utility to darken/lighten hex color
function shadeColor(color, percent) {
    let R = parseInt(color.substring(1,3),16);
    let G = parseInt(color.substring(3,5),16);
    let B = parseInt(color.substring(5,7),16);
    R = parseInt(R * (100 + percent) / 100);
    G = parseInt(G * (100 + percent) / 100);
    B = parseInt(B * (100 + percent) / 100);
    R = (R<255)?R:255;  
    G = (G<255)?G:255;  
    B = (B<255)?B:255;  
    var RR = ((R.toString(16).length==1)?"0"+R.toString(16):R.toString(16));
    var GG = ((G.toString(16).length==1)?"0"+G.toString(16):G.toString(16));
    var BB = ((B.toString(16).length==1)?"0"+B.toString(16):B.toString(16));
    return "#"+RR+GG+BB;
}

function loop() {
    update();
    draw();
    animationId = requestAnimationFrame(loop);
}

/**
 * INPUT HANDLING
 */
function setupInput() {
    // Mouse
    canvas.addEventListener('mousemove', e => {
        const rect = canvas.getBoundingClientRect();
        inputPos.x = e.clientX - rect.left;
        inputPos.y = e.clientY - rect.top;
    });

    canvas.addEventListener('mousedown', shoot);

    // Touch
    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        inputPos.x = e.touches[0].clientX - rect.left;
        inputPos.y = e.touches[0].clientY - rect.top;
    }, { passive: false });

    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        inputPos.x = e.touches[0].clientX - rect.left;
        inputPos.y = e.touches[0].clientY - rect.top;
        shoot();
    }, { passive: false });

    // UI Buttons
    document.getElementById('start-btn').addEventListener('click', () => {
        AudioSys.init();
        startScreen.classList.add('hidden');
        resetGame();
    });
    
    document.getElementById('restart-btn').addEventListener('click', () => {
        gameOverScreen.classList.add('hidden');
        resetGame();
    });

    window.addEventListener('resize', resize);
}

function shoot() {
    if (isGameOver || (bullet && bullet.moving)) return;
    
    AudioSys.init(); // Ensure audio context is ready
    AudioSys.playShoot();
    
    bullet.angle = cannonAngle;
    bullet.moving = true;
}

// Start
initGame();

</script>
</body>
</html>