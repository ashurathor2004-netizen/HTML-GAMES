<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Color T-Rex Runner</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #202124;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            touch-action: none; /* Prevent double tap zoom on mobile */
        }

        #gameContainer {
            position: relative;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
        }

        canvas {
            display: block;
            background-color: #4eb3ff; /* Sky Blue */
            border-radius: 8px;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .score-text {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            text-align: right;
        }

        #start-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(255, 255, 255, 0.8);
            padding: 20px;
            border-radius: 10px;
            pointer-events: auto;
            cursor: pointer;
        }

        h1 { margin: 0 0 10px 0; color: #535353; font-size: 20px; }
        p { margin: 0; color: #666; font-size: 14px; }
    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div id="ui-layer">
        <div class="score-text">HI <span id="highScore">00000</span> &nbsp; <span id="currentScore">00000</span></div>
        <div id="start-message">
            <h1>T-Rex Runner</h1>
            <p>Press SPACE or TAP to Jump</p>
        </div>
    </div>
</div>

<script>
    // --- Configuration ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startMsg = document.getElementById('start-message');
    const scoreEl = document.getElementById('currentScore');
    const highScoreEl = document.getElementById('highScore');

    // Audio Context (Web Audio API)
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx;

    // Game Variables
    let gamePlaying = false;
    let gameSpeed = 6;
    let score = 0;
    let highScore = localStorage.getItem('dinoHighScore') || 0;
    let frameId;
    let obstacles = [];
    
    // Physics
    const GRAVITY = 0.6;
    
    // Dimensions
    const BASE_WIDTH = 800;
    const BASE_HEIGHT = 400;

    // Dino Object
    const dino = {
        x: 50,
        y: 0,
        w: 44,
        h: 47,
        dy: 0,
        jumpForce: 11,
        grounded: false,
        color: '#535353',
        legAnimTimer: 0
    };

    // Ground Object
    const ground = {
        y: 350,
        color: '#f7d54c', // Sandy
        lineColor: '#e0c03e'
    };

    // --- Sound Synthesis ---
    function initAudio() {
        if (!audioCtx) audioCtx = new AudioContext();
        if (audioCtx.state === 'suspended') audioCtx.resume();
    }

    function playSound(type) {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        osc.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        if (type === 'jump') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(150, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1);
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        } else if (type === 'hit') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 0.3);
            gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.3);
        } else if (type === 'score') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(800, audioCtx.currentTime);
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        }
    }

    // --- Core Functions ---

    function resize() {
        // Maintain aspect ratio or fill screen
        let width = window.innerWidth;
        let height = window.innerHeight;
        
        if (width > 800) width = 800;
        if (height > 400) height = 400;
        
        canvas.width = width;
        canvas.height = height;
        
        // Scale logic if needed, but for simplicity we keep fixed logic coordinates
        // and just center the view. For true responsiveness, we'd scale the ctx.
    }

    function spawnObstacle() {
        const size = Math.random() > 0.5 ? 40 : 25;
        const type = Math.random() > 0.8 ? 2 : 1; // 1 = Cactus, 2 = Group
        
        let obs = {
            x: canvas.width + Math.random() * 200,
            y: ground.y - (size + 10), // Adjust to sit on ground
            w: type === 2 ? size * 1.5 : size,
            h: size + 10,
            color: '#28a745' // Cactus Green
        };
        obstacles.push(obs);
    }

    function resetGame() {
        dino.y = ground.y - dino.h;
        dino.dy = 0;
        obstacles = [];
        score = 0;
        gameSpeed = 6;
        gamePlaying = true;
        startMsg.style.display = 'none';
        initAudio();
        requestAnimationFrame(update);
    }

    function gameOver() {
        gamePlaying = false;
        playSound('hit');
        startMsg.innerHTML = `<h1>GAME OVER</h1><p>Score: ${Math.floor(score)}</p><p>Tap to Restart</p>`;
        startMsg.style.display = 'block';
        
        if (score > highScore) {
            highScore = Math.floor(score);
            localStorage.setItem('dinoHighScore', highScore);
        }
        updateScoreUI();
    }

    function jump() {
        if (!gamePlaying) {
            resetGame();
            return;
        }
        if (dino.grounded) {
            dino.dy = -dino.jumpForce;
            dino.grounded = false;
            playSound('jump');
        }
    }

    // --- Drawing ---

    function drawDino() {
        ctx.fillStyle = dino.color;
        
        // Simple shape to look like a Dino
        // Body
        ctx.fillRect(dino.x, dino.y, dino.w, dino.h);
        // Head (offset right)
        ctx.fillRect(dino.x + 20, dino.y - 10, 30, 20);
        // Eye
        ctx.fillStyle = 'white';
        ctx.fillRect(dino.x + 35, dino.y - 5, 5, 5);
        
        // Legs Animation
        ctx.fillStyle = dino.color;
        if (dino.grounded) {
            dino.legAnimTimer++;
            if (dino.legAnimTimer % 10 > 5) {
                // Leg 1
                ctx.fillRect(dino.x + 5, dino.y + dino.h, 10, 10);
            } else {
                // Leg 2
                ctx.fillRect(dino.x + 25, dino.y + dino.h, 10, 10);
            }
        } else {
            // Jumping pose
             ctx.fillRect(dino.x + 10, dino.y + dino.h, 10, 5);
             ctx.fillRect(dino.x + 25, dino.y + dino.h - 5, 10, 5);
        }
    }

    function drawGround() {
        ctx.fillStyle = ground.color;
        ctx.fillRect(0, ground.y, canvas.width, canvas.height - ground.y);
        ctx.fillStyle = ground.lineColor;
        ctx.fillRect(0, ground.y, canvas.width, 4);
    }

    function drawObstacles() {
        ctx.fillStyle = '#28a745';
        obstacles.forEach(obs => {
            ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
            // Draw some details (spikes)
            ctx.fillStyle = '#1e7e34'; 
            ctx.fillRect(obs.x + 5, obs.y + 5, obs.w - 10, obs.h - 10);
            ctx.fillStyle = '#28a745'; // reset
        });
    }

    function drawClouds() {
        // Simple ambient clouds scrolling slower
        const t = Date.now() / 2000;
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        
        // Cloud 1
        let cx1 = (canvas.width - (t * 50) % (canvas.width + 100));
        ctx.fillRect(cx1, 50, 60, 20);
        ctx.fillRect(cx1 + 15, 35, 30, 20);

        // Cloud 2
        let cx2 = (canvas.width - ((t+10) * 30) % (canvas.width + 100));
        ctx.fillRect(cx2, 100, 50, 15);
        ctx.fillRect(cx2 + 10, 90, 20, 15);
    }

    // --- Main Loop ---

    function update() {
        if (!gamePlaying) return;
        requestAnimationFrame(update);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Update Logic
        score += 0.1;
        gameSpeed += 0.001; // Slowly increase speed

        // Dino Physics
        dino.dy += GRAVITY;
        dino.y += dino.dy;

        // Ground Collision
        if (dino.y + dino.h > ground.y) {
            dino.y = ground.y - dino.h;
            dino.dy = 0;
            dino.grounded = true;
        } else {
            dino.grounded = false;
        }

        // Obstacle Logic
        if (Math.random() < 0.015 && obstacles.length < 3) { // 1.5% chance per frame to spawn
             // Ensure reasonable gap between obstacles
             if (obstacles.length === 0 || canvas.width - obstacles[obstacles.length-1].x > 250) {
                 spawnObstacle();
             }
        }

        for (let i = obstacles.length - 1; i >= 0; i--) {
            let obs = obstacles[i];
            obs.x -= gameSpeed;

            // Collision Detection (AABB)
            if (
                dino.x < obs.x + obs.w &&
                dino.x + dino.w > obs.x &&
                dino.y < obs.y + obs.h &&
                dino.y + dino.h > obs.y
            ) {
                gameOver();
                return;
            }

            // Remove off-screen
            if (obs.x + obs.w < 0) {
                obstacles.splice(i, 1);
            }
        }

        // Check for score beep (every 100 points)
        if (Math.floor(score) > 0 && Math.floor(score) % 100 === 0 && Math.floor(score - 0.1) % 100 !== 0) {
            playSound('score');
        }

        // Drawing
        drawClouds();
        drawGround();
        drawObstacles();
        drawDino();
        updateScoreUI();
    }

    function updateScoreUI() {
        scoreEl.innerText = Math.floor(score).toString().padStart(5, '0');
        highScoreEl.innerText = Math.floor(highScore).toString().padStart(5, '0');
    }

    // --- Inputs ---

    window.addEventListener('keydown', (e) => {
        if (e.code === 'Space' || e.code === 'ArrowUp') {
            e.preventDefault(); // Stop scrolling
            jump();
        }
    });

    window.addEventListener('touchstart', (e) => {
        // e.preventDefault(); 
        jump();
    }, {passive: false});
    
    startMsg.addEventListener('click', () => {
        if(!gamePlaying) resetGame();
    });

    // --- Init ---
    resize();
    window.addEventListener('resize', resize);
    highScoreEl.innerText = Math.floor(highScore).toString().padStart(5, '0');

</script>
</body>
</html>